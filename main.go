package main

import (
	"database/sql"
	"net/http"
	"os"
	"strconv"
	"github.com/gin-gonic/gin"
	_ "github.com/go-sql-driver/mysql"
	"github.com/joho/godotenv"
)

var db *sql.DB 

type Book struct {
	ID		 int64
	Title  	 string
	Author   string
	Cover    string
}

func main() {
	// 获取环境变量
	err := godotenv.Load()
	if err != nil {
		panic(err)
	}
	// 开启数据库连接
	db, err = sql.Open("mysql", os.Getenv("DSN"))
	if err != nil {
		panic(err)
	}

	// 设置路由
	router := gin.Default()
	router.GET("/books", GetBooks)
	router.GET("/books/:id", GetSingleBook)
	router.POST("/books", CreateBook)
	router.PUT("/books/:id", UpdateBook)
	router.DELETE("/books/:id", DeleteBook)

	router.Run("localhost:7070")
}

func GetBooks(c *gin.Context) {
	query := "SELECT * FROM books"
	rows, err := db.Query(query)
	defer rows.Close()
	if err != nil {
		panic(err)
	}

	books := []Book{}

	for rows.Next() {
		var book Book
		err := rows.Scan(&book.ID, &book.Title, &book.Author, &book.Cover)
		if err != nil {
			log.Fatal("(GetBooks) res.Scan", err)
		}
		books = append(books, book)
	}
	
	c.IndentedJSON(http.StatusOK, books)
}

func GetSingleBook(c *gin.Context) {
	id := c.Param("id")
	// https://pkg.go.dev/strconv#Atoi
	bookID, err := strconv.Atoi(id)
	if err != nil {
		panic(err)
	}
	 
	var book Book
	err = db.QueryRow(`SELECT * FROM books WHERE id = ?`, bookID).Scan(&book.ID, &book.Title, &book.Author, &book.Cover)
	if err != nil {
		panic(err)
	}

	c.IndentedJSON(http.StatusOK, book)
}

func CreateBook(c *gin.Context) {
	var newBook Book
	err := c.BindJSON(&newBook)
	if err != nil {
		panic(err)
	}

	query := `INSERT INTO books (title, author, cover) VALUES (?, ?, ?)`
	result, err := db.Exec(query, newBook.Title, newBook.Author, newBook.Cover)
	if err != nil {
		panic(err)
	}

	// https://pkg.go.dev/database/sql#Result
	// type Result interface {
	// 	// LastInsertId returns the integer generated by the database
	// 	// in response to a command. Typically this will be from an
	// 	// "auto increment" column when inserting a new row. Not all
	// 	// databases support this feature, and the syntax of such
	// 	// statements varies.
	// 	LastInsertId() (int64, error)

	// 	// RowsAffected returns the number of rows affected by an
	// 	// update, insert, or delete. Not every database or database
	// 	// driver may support this.
	// 	RowsAffected() (int64, error)
	// }

	newBook.ID, err = result.LastInsertId()
	if err != nil {
		panic(err)
	}
	// https://pkg.go.dev/net/http#pkg-constants
	c.IndentedJSON(http.StatusCreated, newBook)
}

func UpdateBook(c *gin.Context) {
	var updates Book
	err := c.BindJSON(&updates)
	if err != nil {
		panic(err)
	}

	id := c.Param("id")
	bookID, err := strconv.Atoi(id)
	if err != nil {
		panic(err)
	}
	
	query := `UPDATE books SET title = ?, author = ?, cover = ? WHERE id = ?`
	_, err = db.Exec(query, updates.Title, updates.Author, updates.Cover, bookID)
	if err != nil {
		panic(err)
	}

	c.Status(http.StatusOK)	
}

func DeleteBook(c *gin.Context) {
	id := c.Param("id")
	bookID, err := strconv.Atoi(id)
	if err != nil {
		panic(err)
	}
	query := `DELETE FROM books WHERE id = ?`
	_, err = db.Exec(query, bookID)
	if err != nil {
		panic(err)
	}

	c.Status(http.StatusOK)
}